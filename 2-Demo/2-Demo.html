<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>2-Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
/*
   This document has been created with Marked.app <http://markedapp.com>, Copyright 2011 Brett Terpstra
   Please leave this notice in place, along with any additional credits below.
   ---------------------------------------------------------------
   Title: Swiss
   Author: Brett Terpstra
   Description: Clean, Swiss typography with no frills.
*/
body{-webkit-font-smoothing:antialiased;font:normal .8764em/1.5em Arial,Verdana,sans-serif;margin:0}html>body{font-size:13px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000;font-size:2.2857em;line-height:.6563em;margin:.6563em 0}h2{color:#111;font-size:1.7143em;line-height:.875em;margin:.875em 0}h3{color:#111;font-size:1.5em;line-height:1em;margin:1em 0}h4{color:#111;font-size:1.2857em;line-height:1.1667em;margin:1.1667em 0}h5{color:#111;font-size:1.15em;line-height:1.3em;margin:1.3em 0}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}h1,h2,h3,h4,h5,h6{line-height:1.5em}a{-webkit-transition:color .2s ease-in-out;color:#0d6ea1;text-decoration:none}a:hover{color:#3593d9}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}#wrapper img{max-width:100%;height:auto}dd{margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 23px;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:23px;padding:0 1em}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;margin-bottom:1.2em;position:relative;margin:1em 0}figcaption{font-style:italic;text-align:center;background:rgba(0,0,0,.9);color:rgba(255,255,255,1);position:absolute;left:0;bottom:-24px;width:98%;padding:1%;-webkit-transition:all .2s ease-in-out}.poetry pre{display:block;font-family:Georgia,Garamond,serif!important;font-size:110%!important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif!important}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(0,0,0,0.06)}@media print{body{overflow:auto}img,pre,blockquote,table,figure,p{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;font-size:85%;padding:10px;position:relative;text-indent:0}}@media screen{.inverted #wrapper,.inverted{background:rgba(37,42,42,1)}.inverted hr{border-color:rgba(51,63,64,1)!important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dd,.inverted dt{color:#eee!important}.inverted table tr:nth-child(odd),.inverted table th:nth-child(odd),.inverted table td:nth-child(odd){background:0}.inverted pre code{color:#111}.inverted a{color:rgba(172,209,213,1)}#wrapper{padding:20px}::selection{background:rgba(157,193,200,.5)}h1::selection{background-color:rgba(45,156,208,.3)}h2::selection{background-color:rgba(90,182,224,.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,.3)}code::selection{background-color:rgba(0,0,0,.7);color:#eee}code span::selection{background-color:rgba(0,0,0,.7)!important;color:#eee!important}a::selection{background-color:rgba(255,230,102,.2)}.inverted a::selection{background-color:rgba(255,230,102,.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,.5)}}
</style>

</head>
<body class="normal">
  <div id="wrapper">
      <h1>204: Swift Functional Programming</h1>

<h2>Introduction</h2>

<p>First we briefly consider how to model the Game of Life in an OOP vs
functional style.</p>

<p>The starter shows the beginning of an implementation in a less
functional style, which relies on mutable variables and impure
functions that mutate those variables.</p>

<h1>Step 1 - Observe aliasing</h1>

<p>We set only (0,0) alive. Add this line to check if cell (1,0) is alive:</p>

<pre><code>g.isCellAliveAt(1, 0)
</code></pre>

<p>Observe that it is alive! This is a problem with <em>aliasing</em>, two names
referring to the same object.</p>

<p>Because we create the grid by appending the same initial column, and
because MCell is a reference type, all the cells in one row point to
the object.</p>

<p>The essential problem is that we need to keep track of both <em>names</em>
and <em>objects</em>.</p>

<h2>Step 2 - Fix aliasing problem by instance management</h2>

<p>We need to ensure every column contains a distinct array of distinct
MCell instances.</p>

<p>Rewrite the MGrid initializer to move the loop that creates a column
inside the loop that creates a row:</p>

<pre><code>var columns:[[MCell]]
init() {
  var grid:[[MCell]] = []
  for columnIndex in 0..&lt;10 {
    var column:[MCell] = []
    for rowIndex in 0..&lt;10 {
      column.append(MCell())
    }

    grid.append(column)
  }

  self.columns = grid
}
</code></pre>

<p>Now every cell is a distinct instance.</p>

<p>We fixed the aliasing problem by keeping track of aliases.</p>

<h1>Step 3 - Fix aliasing problem with value type collections and data</h1>

<p>Make MCell into a struct:</p>

<pre><code>struct MCell {
  var alive:Bool
  init() { self.alive = false }
}
</code></pre>

<p>and update the setter to remove the cast:</p>

<pre><code>func setCell(columnIndex:Int,_ rowIndex:Int,_ alive:Bool) -&gt; Void {
  self.columns[columnIndex][rowIndex].alive = alive
}
</code></pre>

<p>Now it works.</p>

<p>The moral: if you use value types (structs and enums), then you do not
need to track the the <em>identity</em> of objects separately from their
<em>values</em>. You can think only about values, more like in mathematics.</p>

<p>(You could do even better by using immutable types, whether class
types or value types. Wihout mutability, aliasing is irrelevant.)</p>

<h1>Step 4 - Consider how to implement Game of Life</h1>

<p>Start implementing a function to update the grid:</p>

<pre><code>func updateBoard(inout grid:MGrid) -&gt; Void {
  for col in grid.columns {
    for cell in col {
      let isAlive = cell.alive
      // count living neighbors
      // and put results ... ?
    }
  }
}
</code></pre>

<p>As these loops run, we move across the board setting setting cells.</p>

<p>But how do we set the cell to its new value and then, when computing
its neighbors value, correctly use the original cell&#8217;s old value?</p>

<p>Moral: Mutation is hard to keep track of. What has mutated? When?</p>

<p>So maybe we need to make a copy of the entire board? But that&#8217;s almost
&#8220;functional&#8221; &#8211; then we&#8217;re actually just computing an entirely new
value for the board, rather than mutating the one board that progress
through time, as was our original plan.</p>

<h2>Step 5 - Consider FP-style representation of a board and cell</h2>

<p>Erase everything and define this new immutable struct which represents a <em>living cell</em>:</p>

<pre><code>struct Cell
{
  let x:Int
  let y:Int
}

// MARK: Equatable
/// Two cells are equal iff all their members are equal
func ==(lhs: Cell, rhs: Cell) -&gt; Bool {
  return lhs.x == rhs.x &amp;&amp; lhs.y == rhs.y
}

// MARK: Hashable
extension Cell : Hashable {
  var hashValue : Int { return self.x.hashValue ^ self.y.hashValue  }
}
</code></pre>

<p>(Implementing Equatable and Hashable is a necessary pain. You always need equality.)</p>

<h2>Step 6 - Represent board as just the collection of living cells</h2>

<p>Enter this representation for a board with one live cell:</p>

<pre><code>let initialBoard = [Cell(x:0,y:0)]
</code></pre>

<p>We will represent evolution through time as computing one entire
immutable value for the whole board from another. This is immutable
and simple.</p>

<h2>Step 7 - Generating a cell&#8217;s neighbors:</h2>

<p>Write this function for generating a cell&#8217;s neighbors:</p>

<pre><code>func neighbors(OfCell cell:Cell) -&gt; [Cell]
{
  let deltas = [(-1,-1),(0,-1),(1,-1),
                (-1, 0),       (1,0 ),
                (-1, 1),(0, 1),(1, 1)]

  var neighbors = [Cell]()
  for delta in deltas {
    neighbors.append( Cell(x: cell.x + delta.0, y: cell.y + delta.1) )
  }
  return neighbors
}
</code></pre>

<p>We loop over a collection to build a new collection &#8211; a common
pattern. The fixed part is the loop and build. The changing part is
inside append.</p>

<h2>Step 8 - Use &#8220;map&#8221; to simplify the function neighbors</h2>

<p>The function <code>map</code> is used to generate a new collection by applying a
transform to every element in a collection. Use map to refactor:</p>

<pre><code>func neighbors(OfCell cell:Cell) -&gt; [Cell]
{
  let deltas = [(-1,-1),(0,-1),(1,-1),
                (-1, 0),       (1,0 ),
                (-1, 1),(0, 1),(1, 1)]

  return map(deltas, { Cell(x: cell.x + $0.0, y: cell.y + $0.1) } )
}
</code></pre>

<h2>Step 9 - Implement time-evolution logic with loops</h2>

<p>Add the following time-evolution function:</p>

<pre><code>/// compute next cells, using no HOFs
func activeCellsOneStepAfter1(activeCells:[Cell]) -&gt; [Cell]
{
  // loop and build array of cells neighboring active cells
  var neighborings = [Cell]()
  for cell in activeCells {
    for neighborOfCell in neighbors(OfCell: cell) {
      neighborings.append(neighborOfCell)
    }
  }

  // loop and count duplicate neighborings
  var neighboringsPerCell = Dictionary&lt;Cell,Int&gt;()
  for neighboringCell in neighborings {
    if let value = neighboringsPerCell[neighboringCell] {
      neighboringsPerCell[neighboringCell] = value + 1
    }
    else {
      neighboringsPerCell[neighboringCell] = 1
    }
  }

  // loop to filter
  var neighboringsActiveNextStep = [Cell]()
  for (theNeighbor,neighborCount) in neighboringsPerCell {
    if       (neighborCount == 3) ||
    (neighborCount == 2 &amp;&amp; find(activeCells,theNeighbor) != nil)
    {
      neighboringsActiveNextStep.append(theNeighbor)
    }
  }

  return neighboringsActiveNextStep
}
</code></pre>

<p>How does this work? We build up a list of all &#8220;neighborings&#8221; &#8211; all
instances of a cell neighboring a live cell. This list will include
the same cell multiple times if a cell is a neighbor to multiple
distinct live cells.</p>

<p>Then for every cell <em>next</em> to such a neighboring, we count the number
of neighborings it has, and we use that count to determine whether it
is alive in the next time step.</p>

<p>(This is a bit tricky. It works because Conway&#8217;s algorithm is
spatially local. For instance, if the rules allowed certain patterns
of live cells to cast spores many spaces away, then just looking near
the neighborings would not suffice.)</p>

<h2>Step 10 - Use filter to simplify the last step</h2>

<p>The loop-and-filter stanza loops, checks a condition, and builds up a
new collection. This is a common pattern abstracted through the hgiher
order function <code>filter</code>.</p>

<p>Replace the the loop-to-filter paragraph with this use of filter:</p>

<pre><code>func isActiveNextStep(cell:Cell, neighboringCount:Int) -&gt; Bool
{
  return
    (neighboringCount == 3) ||
      (neighboringCount == 2 &amp;&amp; find(activeCells,cell) != nil)
}
let neighboringsActiveNextStep:[(Cell,Int)] = filter(neighboringsPerCell, isActiveNextStep )
</code></pre>

<h2>Step 11 - insert these functions into the project</h2>

<p>Add these functions to Conway.swift in the project in starter/before.</p>

<p>Run!</p>
    </div>
</body>
</html>